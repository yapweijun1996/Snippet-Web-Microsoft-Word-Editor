<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Snippet Web Microsoft Word Editor ‚Äî with Page & Image Controls</title>
<style>
  /* --- Reset / Base --- */
  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body {
    margin: 0;
    font-family: Calibri, "Segoe UI", Arial, sans-serif;
    background: #f5f5f5;
    color: #222;
  }
  body.modal-open { overflow: hidden; }
  .launch-bar {
    padding: 48px 24px;
    text-align: center;
    background: linear-gradient(135deg, #f5f5f5 30%, #e1e9ff 100%);
    min-height: 100vh;
    display: grid;
    place-items: center;
  }
  .launch-card {
    background: #fff;
    border-radius: 12px;
    box-shadow: 0 12px 30px rgba(43,87,154,0.15);
    padding: 36px 48px;
    max-width: 420px;
  }
  .launch-card h1 { margin: 0 0 12px; font-size: 22px; color: #2b579a; }
  .launch-card p { margin: 0 0 24px; color: #4a4a4a; line-height: 1.6; }
  .launch-btn {
    display: inline-flex; align-items: center; gap: 8px;
    background: #2b579a; color: #fff; border: none;
    border-radius: 6px; padding: 12px 24px; cursor: pointer;
    font-size: 15px; font-weight: 600;
    box-shadow: 0 8px 20px rgba(43,87,154,0.25);
  }
  .launch-btn:hover { background: #244b86; }
  body.modal-open .launch-bar { display: none; }
  .pill {
    display: inline-block;
    padding: 0 10px;
    height: 24px;
    line-height: 24px;
    border-radius: 12px;
    background: #d2e3fc;
    color: #1a3d7c;
    font-size: 12px;
    font-weight: 600;
  }
  .editor-modal {
    position: fixed; inset: 0; background: rgba(0,0,0,0.45);
    display: none; align-items: stretch; justify-content: center;
    z-index: 3000; padding: 0;
    overflow: hidden;
  }
  .editor-modal.active { display: flex; }
  .editor-shell {
    background: #fff; border-radius: 0; width: 100%; max-width: none;
    display: flex; flex-direction: column; overflow: hidden;
    box-shadow: none;
    height: 100vh;
  }
  .editor-frame {
    background: #f5f5f5;
    flex: 1;
    display: flex; flex-direction: column;
    min-height: 0;
  }
  .header {
    background: #2b579a; color: #fff; padding: 8px 12px;
    display: flex; align-items: center; justify-content: space-between;
  }
  .header h1 { font-size: 16px; font-weight: 600; margin: 0; }
  .header-actions { display: flex; gap: 8px; align-items: center; }
  .toolbar {
    position: sticky; top: 0; z-index: 100; background: #f1f1f1;
    border-bottom: 1px solid #ddd; padding: 6px 8px; display: flex; flex-wrap: wrap; gap: 8px;
  }
  .group { display: inline-flex; align-items: center; gap: 6px; padding-right: 10px; border-right: 1px solid #ddd; }
  .group:last-child { border-right: 0; }
  .btn {
    height: 28px; min-width: 28px; padding: 0 8px; border: 1px solid #ddd; background: #fff;
    border-radius: 3px; cursor: pointer; font-size: 13px; display: inline-flex; align-items: center; justify-content: center;
  }
  .btn:hover { background: #e8f0fe; border-color: #1976d2; }
  .btn.active { background: #d2e3fc; border-color: #1976d2; }
  .btn:disabled {
    opacity: 0.45;
    cursor: not-allowed;
    background: #f5f5f5;
    border-color: #ddd;
  }
  select, input[type="number"], input[type="text"] {
    height: 28px; border: 1px solid #ddd; background: #fff; padding: 0 6px; border-radius: 3px; font-size: 13px;
  }
  .color-btn {
    width: 28px; height: 28px; border: 1px solid #ddd; background: #fff; position: relative; border-radius: 3px;
    display: inline-flex; align-items: center; justify-content: center; cursor: pointer; font-weight: 700;
  }
  .color-preview { position: absolute; left: 0; right: 0; bottom: 2px; height: 6px; border-top: 1px solid #eee; }
  .sr-file {
    position: fixed;
    top: -1000px;
    left: -1000px;
    width: 0.1px;
    height: 0.1px;
    opacity: 0;
    pointer-events: none;
  }

  /* --- Canvas / Page --- */
  .canvas {
    flex: 1;
    overflow: auto;
    background: #e8e8e8;
    padding: 20px 0 60px;
    min-height: 0;
  }
  .page-wrap {
    margin: 0 auto;
    box-shadow: 0 0 5px rgba(0,0,0,.15);
    background: #fff;
    position: relative;
    transform-origin: top center;
  }
  .page-content {
    outline: none;
    min-height: 10mm;
  }
  /* default (will be overridden by JS per selection) */
  .page-wrap { width: 210mm; }
  .page-content { padding: 20mm; font-size: 11pt; line-height: 1.5; }

  .page-break {
    height: 0; margin: 12px 0; border-top: 2px dashed #9aa0a6;
    position: relative; break-after: page; page-break-after: always;
  }
  .page-break::after {
    content: "Page Break";
    position: absolute; top: -12px; left: 50%; transform: translateX(-50%);
    font-size: 11px; color: #5f6368; background: #f5f5f5; padding: 0 6px;
  }

  /* --- Status bar --- */
  .status {
    position: sticky;
    bottom: 0;
    background: #f1f1f1; border-top: 1px solid #ddd;
    display: flex; align-items: center; justify-content: space-between;
    padding: 6px 12px; font-size: 12px; z-index: 10;
  }

  /* --- Modals (simple) --- */
  .modal { display: none; position: fixed; inset: 0; background: rgba(0,0,0,.45); align-items: center; justify-content: center; z-index: 2000; }
  .modal.active { display: flex; }
  .modal-card { background: #fff; width: min(92vw, 520px); padding: 16px; border-radius: 6px; }
  .modal-head { display:flex; align-items:center; justify-content:space-between; margin-bottom: 10px; }
  .close-x { font-size: 22px; cursor: pointer; color: #777; }
  .form-row { margin-bottom: 10px; display: grid; grid-template-columns: 140px 1fr; gap: 10px; align-items: center; }
  .modal-actions { display: flex; gap: 8px; justify-content: flex-end; }

  /* --- Image selection adornments --- */
  .img-selected { outline: 2px solid #4285f4; }
  .img-handle {
    position: absolute; width: 10px; height: 10px; background: #4285f4; border-radius: 50%;
    right: -5px; bottom: -5px; cursor: se-resize; z-index: 50;
  }
  .img-toolbar, .table-toolbar {
    position: fixed; z-index: 3000; background: #fff; border: 1px solid #ddd; border-radius: 6px;
    box-shadow: 0 4px 18px rgba(0,0,0,.12); padding: 8px; display: none; min-width: 280px;
  }
  .img-toolbar .row, .table-toolbar .row { display: flex; align-items: center; gap: 6px; margin: 6px 0; flex-wrap: wrap; }
  .img-toolbar label, .table-toolbar label { font-size: 12px; color: #555; }
  td.cell-selected, th.cell-selected { outline: 2px solid #34a853; outline-offset: -2px; }

  /* --- Printing --- */
  @media print {
    body { background: #fff; }
    .header, .toolbar, .status, .img-toolbar, .table-toolbar { display: none !important; }
    .editor-modal, .editor-shell, .editor-frame {
      position: static;
      display: block;
      height: auto !important;
      overflow: visible !important;
    }
    .canvas {
      padding: 0;
      overflow: visible !important;
      height: auto !important;
    }
    .page-wrap { box-shadow: none; margin: 0; width: auto; transform: none !important; }
    .page-content { padding: 0; }
    .page-break { border: none; height: 0; }
  }
</style>

<!-- dynamic print style for @page will be injected here -->
<style id="printStyle">
  @page { size: A4 portrait; margin: 20mm; }
</style>
</head>
<body>
  <div class="launch-bar">
    <div class="launch-card">
      <h1>Snippet Web Microsoft Word Editor</h1>
      <p>Paste or import Word documents into a front-end-only workspace with A4 pagination, autosave, and export.</p>
      <button class="launch-btn" id="launchEditor">üöÄ Launch Editor</button>
    </div>
  </div>

  <div class="editor-modal" id="editorModal" role="dialog" aria-modal="true" aria-labelledby="editorTitle">
    <div class="editor-shell">
      <div class="editor-frame">
  <div class="header">
    <h1 id="editorTitle">üìù Web Word-like Editor</h1>
    <div class="header-actions">
      <button type="button" class="btn" id="btnNew">New</button>
      <button type="button" class="btn" id="btnOpen">Open</button>
      <button type="button" class="btn" id="btnSave">Save</button>
      <button type="button" class="btn" id="btnPrint">Print</button>
      <button type="button" class="btn" id="btnCloseEditor" title="Close editor">√ó</button>
    </div>
  </div>

  <!-- Toolbar -->
  <div class="toolbar" role="toolbar" aria-label="Editor toolbar">
    <!-- Undo/Redo -->
    <div class="group">
      <button type="button" class="btn" id="btnUndo" title="Undo">‚Ü∂</button>
      <button type="button" class="btn" id="btnRedo" title="Redo">‚Ü∑</button>
    </div>

    <!-- Clipboard -->
    <div class="group">
      <button class="btn" data-cmd="cut" title="Cut">‚úÇ</button>
      <button class="btn" data-cmd="copy" title="Copy">üìã</button>
      <button class="btn" id="btnPaste" title="Paste">üìå</button>
    </div>

    <!-- Font -->
    <div class="group">
      <select id="fontName" title="Font family">
        <option value="">Font</option>
        <option>Arial</option>
        <option selected>Calibri</option>
        <option>Cambria</option>
        <option>Courier New</option>
        <option>Georgia</option>
        <option>Times New Roman</option>
        <option>Verdana</option>
      </select>
      <select id="fontSize" title="Font size (pt)">
        <option value="">Size</option>
        <option>8</option><option>9</option><option>10</option><option>11</option><option>12</option>
        <option>14</option><option>16</option><option>18</option><option>20</option><option>22</option>
        <option>24</option><option>28</option><option>36</option><option>48</option><option>72</option>
      </select>
      <button class="btn" data-cmd="bold"><b>B</b></button>
      <button class="btn" data-cmd="italic"><i>I</i></button>
      <button class="btn" data-cmd="underline"><u>U</u></button>
      <button class="btn" data-cmd="strikeThrough"><s>S</s></button>
      <button class="btn" data-cmd="subscript">x‚ÇÇ</button>
      <button class="btn" data-cmd="superscript">x¬≤</button>
    </div>

    <!-- Colors -->
    <div class="group">
      <button class="color-btn" id="btnColorText" title="Text color">A<div class="color-preview" id="cpText" style="background:black;"></div></button>
      <input type="color" id="colorText" style="display:none" value="#000000"/>
      <button class="color-btn" id="btnColorHilite" title="Highlight">A<div class="color-preview" id="cpHilite" style="background:yellow;"></div></button>
      <input type="color" id="colorHilite" style="display:none" value="#ffff00"/>
    </div>

    <!-- Align & Lists -->
    <div class="group">
      <button class="btn" data-cmd="justifyLeft" title="Align left">‚¨Ö</button>
      <button class="btn" data-cmd="justifyCenter" title="Align center">‚¨å</button>
      <button class="btn" data-cmd="justifyRight" title="Align right">‚û°</button>
      <button class="btn" data-cmd="justifyFull" title="Justify">‚ò∞</button>
      <button class="btn" data-cmd="insertOrderedList" title="Numbered list">1.</button>
      <button class="btn" data-cmd="insertUnorderedList" title="Bulleted list">‚Ä¢</button>
      <button class="btn" data-cmd="outdent" title="Outdent">‚á§</button>
      <button class="btn" data-cmd="indent" title="Indent">‚á•</button>
      <select id="listStyle" title="List style">
        <option value="">List style</option>
        <option value="ul:disc">‚Ä¢ Disc</option>
        <option value="ul:circle">‚óã Circle</option>
        <option value="ul:square">‚ñ† Square</option>
        <option value="ol:decimal">1. Decimal</option>
        <option value="ol:lower-alpha">a. Lower alpha</option>
        <option value="ol:upper-alpha">A. Upper alpha</option>
        <option value="ol:lower-roman">i. Lower roman</option>
        <option value="ol:upper-roman">I. Upper roman</option>
      </select>
    </div>

    <!-- Insert -->
    <div class="group">
      <button class="btn" id="btnLink" title="Insert link">üîó</button>
      <button class="btn" id="btnImage" title="Insert image">üñº</button>
      <button class="btn" id="btnTable" title="Insert table">‚äû</button>
      <button type="button" class="btn" data-cmd="insertHorizontalRule" title="Horizontal line">‚Äî</button>
      <button class="btn" id="btnPageBreak" title="Insert page break">‚§ì</button>
    </div>

    <!-- Page Setup -->
    <div class="group" title="Page setup">
      <span style="font-size:12px;color:#555;">Paper:</span>
      <span class="pill" aria-label="Paper size locked to A4">A4</span>
      <select id="orientation">
        <option>portrait</option>
        <option>landscape</option>
      </select>
      <label style="font-size:12px;color:#555;">Margins (mm):</label>
      <input type="number" id="margin" value="20" min="5" max="50" style="width:64px" />
      <label style="font-size:12px;color:#555;">Zoom:</label>
      <select id="zoom">
        <option>80%</option><option>90%</option><option selected>100%</option><option>110%</option><option>125%</option><option>150%</option>
      </select>
    </div>

    <!-- Tools -->
    <div class="group">
      <button type="button" class="btn" id="btnFind" title="Find & Replace">üîç</button>
      <button type="button" class="btn" id="btnClearFormat" title="Clear formatting">‚úñ</button>
    </div>
  </div>

  <!-- Canvas / Page -->
  <div class="canvas">
    <div class="page-wrap" id="pageWrap">
      <div class="page-content" id="editor" contenteditable="true" spellcheck="true">
        <h1 style="text-align:center;">Welcome!</h1>
        <p>Paste from Word and keep your formatting (bold, italic, underline, alignment, lists, tables, etc.).</p>
        <p>Try inserting an image ‚Äî click it to control size, alignment, wrap, border, radius, shadow, or drag the corner handle to resize.</p>
        <p>You can also insert a <em>Page Break</em>, and dial in A4 orientation + margins with real mm units. Print uses real <code>@page</code> rules.</p>
      </div>
    </div>
  </div>
      </div>

  <!-- Status -->
  <div class="status">
    <div>Words: <span id="statWords">0</span> &nbsp; Characters: <span id="statChars">0</span></div>
    <div id="saveStatus">Ready</div>
  </div>

  <!-- Hidden inputs -->
  <input type="file" id="fileOpen" accept=".html,.htm,.txt,.docx" class="sr-file" tabindex="-1" />
  <input type="file" id="fileImg" accept="image/*" class="sr-file" tabindex="-1" />
    </div>
  <!-- Link modal -->
  <div class="modal" id="modalLink">
    <div class="modal-card">
      <div class="modal-head">
        <h3>Insert Link</h3>
        <span class="close-x" data-close="modalLink">√ó</span>
      </div>
      <div class="form-row">
        <label>URL</label>
        <input type="text" id="linkURL" placeholder="https://example.com"/>
      </div>
      <div class="form-row">
        <label>Text (optional)</label>
        <input type="text" id="linkText" placeholder="Text to display"/>
      </div>
      <div class="modal-actions">
        <button class="btn" data-close="modalLink">Cancel</button>
        <button class="btn" id="doInsertLink" style="background:#1976d2;color:#fff;border:0;">Insert</button>
      </div>
    </div>
  </div>

  <!-- Table modal -->
  <div class="modal" id="modalTable">
    <div class="modal-card">
      <div class="modal-head">
        <h3>Insert Table</h3>
        <span class="close-x" data-close="modalTable">√ó</span>
      </div>
      <div class="form-row">
        <label>Rows</label><input type="number" id="tblRows" min="1" max="100" value="3"/>
      </div>
      <div class="form-row">
        <label>Columns</label><input type="number" id="tblCols" min="1" max="20" value="3"/>
      </div>
      <div class="modal-actions">
        <button class="btn" data-close="modalTable">Cancel</button>
        <button class="btn" id="doInsertTable" style="background:#1976d2;color:#fff;border:0;">Insert</button>
      </div>
    </div>
  </div>

  <!-- Find/Replace modal -->
  <div class="modal" id="modalFind">
    <div class="modal-card">
      <div class="modal-head">
        <h3>Find & Replace</h3>
        <span class="close-x" data-close="modalFind">√ó</span>
      </div>
      <div class="form-row">
        <label>Find</label><input type="text" id="findTxt"/>
      </div>
      <div class="form-row">
        <label>Replace</label><input type="text" id="replTxt"/>
      </div>
      <div class="modal-actions">
        <button class="btn" id="doFind">Find next</button>
        <button class="btn" id="doReplace">Replace</button>
        <button class="btn" id="doReplaceAll" style="background:#1976d2;color:#fff;border:0;">Replace all</button>
      </div>
    </div>
  </div>

  <!-- Floating Image Toolbar -->
  <div class="img-toolbar" id="imgToolbar" role="dialog" aria-label="Image tools">
    <div class="row">
      <label>Width:</label>
      <input type="range" id="imgWidth" min="20" max="1600" value="300" style="width:140px"/>
      <label><input type="checkbox" id="imgLock" checked/> Lock ratio</label>
      <span id="imgSizeLabel" style="font-size:12px;color:#555;">300√ó‚Äî</span>
    </div>
    <div class="row">
      <label>Align:</label>
      <button class="btn" id="imgAlignLeft">Left</button>
      <button class="btn" id="imgAlignCenter">Center</button>
      <button class="btn" id="imgAlignRight">Right</button>
      <button class="btn" id="imgFloatLeft" title="Wrap left">Wrap ‚¨Ö</button>
      <button class="btn" id="imgFloatRight" title="Wrap right">Wrap ‚û°</button>
      <button class="btn" id="imgFloatNone" title="No wrap">No wrap</button>
    </div>
    <div class="row">
      <label>Border:</label>
      <button class="btn" id="imgBorderToggle">On/Off</button>
      <label>Radius</label><input type="range" id="imgRadius" min="0" max="40" value="0" style="width:100px"/>
      <label>Shadow</label><button class="btn" id="imgShadowToggle">On/Off</button>
    </div>
    <div class="row">
      <button class="btn" id="imgReplace">Replace URL</button>
      <button class="btn" id="imgUpload">Upload‚Ä¶</button>
      <button class="btn" id="imgRemove" style="color:#b00020;border-color:#f3cbd0;">Remove</button>
    </div>
  </div>

  <div class="table-toolbar" id="tableToolbar" role="dialog" aria-label="Table tools">
    <div class="row">
      <button class="btn" id="tblAddRowAbove" title="Add row above">Row ‚Üë</button>
      <button class="btn" id="tblAddRowBelow" title="Add row below">Row ‚Üì</button>
      <button class="btn" id="tblAddColLeft" title="Add column left">Col ‚Üê</button>
      <button class="btn" id="tblAddColRight" title="Add column right">Col ‚Üí</button>
      <button class="btn" id="tblDeleteRow" title="Delete row" style="color:#b00020;">Del Row</button>
      <button class="btn" id="tblDeleteCol" title="Delete column" style="color:#b00020;">Del Col</button>
    </div>
    <div class="row">
      <button class="btn" id="tblToggleHeader" title="Toggle header row">Header</button>
      <label>Align:</label>
      <button class="btn" id="tblAlignLeft">Left</button>
      <button class="btn" id="tblAlignCenter">Center</button>
      <button class="btn" id="tblAlignRight">Right</button>
    </div>
    <div class="row">
      <label>Borders:</label>
      <button class="btn" data-border="all">All</button>
      <button class="btn" data-border="none">None</button>
      <button class="btn" data-border="top">Top</button>
      <button class="btn" data-border="right">Right</button>
      <button class="btn" data-border="bottom">Bottom</button>
      <button class="btn" data-border="left">Left</button>
    </div>
  </div>
</div>
<script src="libs/mammoth.browser.min.js"></script>
<script>
  // --- References ---
  const editor = document.getElementById('editor');
  const pageWrap = document.getElementById('pageWrap');
  const pageContent = document.querySelector('.page-content');
  const printStyle = document.getElementById('printStyle');
  const editorModal = document.getElementById('editorModal');
  const launchBtn = document.getElementById('launchEditor');
  const closeEditorBtn = document.getElementById('btnCloseEditor');
  const printBtn = document.getElementById('btnPrint');
  const saveStatusEl = document.getElementById('saveStatus');
  const bodyEl = document.body;
  const fileOpenInput = document.getElementById('fileOpen');
  const fileImgInput = document.getElementById('fileImg');
  const listStyleSelect = document.getElementById('listStyle');
  const undoBtn = document.getElementById('btnUndo');
  const redoBtn = document.getElementById('btnRedo');
  const clearFormatBtn = document.getElementById('btnClearFormat');

  const STORAGE_KEY = `webword:v1:${location.href}`;

  let isModalOpen = false;
  let hasRestored = false;
  let autoSaveTimer = null;
  let statusResetTimer = null;
  let needsSave = false;
  let pendingImageInsert = false;
  let docHistory = [];
  let historyIndex = -1;
  let isApplyingHistory = false;
  let historyDebounce = null;

  const MAX_IMAGE_BYTES = 2.5 * 1024 * 1024; // ‚âà2.5MB threshold
  const IMAGE_QUALITY = 0.82;
  const MAX_HISTORY_ENTRIES = 50;
  const HISTORY_DEBOUNCE_MS = 350;
  const CLEARABLE_TAGS = new Set(['SPAN','FONT','B','I','U','STRONG','EM','SUP','SUB','P','DIV','H1','H2','H3','H4','H5','H6','TD','TH','LI','A']);
  const NON_MUTATING_CMDS = new Set(['copy']);

  const ALLOWED_TAGS = new Set([
    'p','h1','h2','h3','h4','h5','h6','span','b','strong','i','em','u','sup','sub','ul','ol','li',
    'table','thead','tbody','tr','td','th','hr','img','a','br','div'
  ]);
  const DROP_CONTENT_TAGS = new Set(['script','style','meta','link','iframe','object','embed','form','button','input','textarea','select','svg','canvas','noscript']);
  const ALLOWED_ATTRS = new Set(['style','href','target','rel','src','colspan','rowspan','alt']);
  const URL_ATTRS = new Set(['href','src']);
  const SAFE_TARGETS = new Set(['_blank','_self']);
  const ALLOWED_STYLES = new Set([
    'font-weight','font-style','text-decoration','color','background-color','font-size','line-height','text-align','vertical-align',
    'margin','padding','border','border-top','border-right','border-bottom','border-left','border-collapse','border-spacing','list-style-type',
    'width','height','max-width','max-height','min-width','min-height','background','text-indent','white-space'
  ]);

  // --- Paper sizes in mm (A4 only for MVP) ---
  const PAPER_MM = {
    A4: { w: 210, h: 297 }
  };

  // --- Init ---
  window.addEventListener('load', () => {
    restoreFromStorage();
    updateStats();

    // wire toolbar generic execCommand
    document.querySelectorAll('[data-cmd]').forEach(b => {
      b.addEventListener('click', () => execCmd(b.getAttribute('data-cmd')));
    });

    if (undoBtn) {
      undoBtn.addEventListener('click', e => { e.preventDefault(); undoHistory(); });
      undoBtn.disabled = true;
    }
    if (redoBtn) {
      redoBtn.addEventListener('click', e => { e.preventDefault(); redoHistory(); });
      redoBtn.disabled = true;
    }

    // launch / close modal
    launchBtn.addEventListener('click', openEditorModal);
    closeEditorBtn.addEventListener('click', closeEditorModal);
    printBtn.addEventListener('click', handlePrint);

    // colors
    document.getElementById('btnColorText').onclick = () => document.getElementById('colorText').click();
    document.getElementById('btnColorHilite').onclick = () => document.getElementById('colorHilite').click();
    document.getElementById('colorText').onchange = (e)=>{ execCmd('foreColor', e.target.value); document.getElementById('cpText').style.background = e.target.value; };
    document.getElementById('colorHilite').onchange = (e)=>{ execCmd('hiliteColor', e.target.value); document.getElementById('cpHilite').style.background = e.target.value; };

    // font family / size
    document.getElementById('fontName').onchange = (e)=> execCmd('fontName', e.target.value);
    document.getElementById('fontSize').onchange = (e)=> setFontSizePt(e.target.value);

    // page setup (A4 locked, orientation still respected)
    document.getElementById('orientation').onchange = applyPageSetup;
    document.getElementById('margin').oninput = applyPageSetup;
    document.getElementById('zoom').onchange = applyZoom;
    applyPageSetup();
    applyZoom();

    // paste
    document.getElementById('btnPaste').onclick = doPaste;
    editor.addEventListener('paste', onPasteSanitized);

    // typing / selection
    editor.addEventListener('input', onDirty);
    editor.addEventListener('keyup', updateStats);
    editor.addEventListener('mouseup', updateStats);

    // file
    document.getElementById('btnNew').onclick = newDoc;
    document.getElementById('btnOpen').onclick = ()=> fileOpenInput.click();
    document.getElementById('btnSave').onclick = saveDoc;
    fileOpenInput.addEventListener('change', handleOpenFile);

    // link / table / page break
    document.getElementById('btnLink').onclick = openLinkModal;
    document.querySelectorAll('[data-close]').forEach(el=> el.onclick = ()=> closeModal(el.getAttribute('data-close')));
    document.querySelectorAll('.close-x').forEach(el=> el.onclick = ()=> closeModal(el.getAttribute('data-close')));
    document.getElementById('doInsertLink').onclick = doInsertLink;
    document.getElementById('btnTable').onclick = ()=> openModal('modalTable');
    document.getElementById('doInsertTable').onclick = doInsertTable;
    document.getElementById('btnPageBreak').onclick = insertPageBreak;
    if (listStyleSelect) listStyleSelect.onchange = handleListStyleChange;

    // find/replace
    document.getElementById('btnFind').onclick = ()=> openModal('modalFind');
    document.getElementById('doFind').onclick = doFindNext;
    document.getElementById('doReplace').onclick = doReplaceOne;
    document.getElementById('doReplaceAll').onclick = doReplaceAll;
    if (clearFormatBtn) {
      clearFormatBtn.addEventListener('click', e => { e.preventDefault(); clearFormatting(); });
    }

    // image controls
    wireImageTools();
    wireTableTools();

    resetHistory();
  });

window.addEventListener('beforeunload', flushAutoSave);

  function restoreFromStorage(){
    if (hasRestored) return;
    const saved = localStorage.getItem(STORAGE_KEY);
    if (saved) editor.innerHTML = saved;
    hasRestored = true;
  }

  function openEditorModal(){
    restoreFromStorage();
    isModalOpen = true;
    bodyEl.classList.add('modal-open');
    editorModal.classList.add('active');
    saveStatusEl.textContent = needsSave ? 'Unsaved' : 'Ready';
    updateStats();
    updateListStyleControl();
    syncTableSelection();
    try { editor.focus({ preventScroll: true }); } catch(_) { editor.focus(); }
  }

  function closeEditorModal(){
    flushAutoSave();
    isModalOpen = false;
    bodyEl.classList.remove('modal-open');
    editorModal.classList.remove('active');
    dismissImageTools();
    dismissTableTools();
    ['modalLink','modalTable','modalFind'].forEach(id => closeModal(id));
    saveStatusEl.textContent = 'Ready';
    updateListStyleControl();
  }

  function handlePrint(){
    if (!isModalOpen) return;
    flushAutoSave();
    requestAnimationFrame(() => window.print());
  }

  // --- Exec command wrapper ---
  function execCmd(cmd, val=null) {
    document.execCommand(cmd, false, val);
    editor.focus();
    if (!NON_MUTATING_CMDS.has(cmd)) {
      onDirty();
    }
  }

  function setFontSizePt(pt) {
    if (!pt) return;
    // Wrap selection in span with font-size:pt (reliable across engines)
    const sel = window.getSelection();
    if (!sel || sel.rangeCount===0) return;
    const range = sel.getRangeAt(0);
    const span = document.createElement('span');
    span.style.fontSize = pt + 'pt';
    range.surroundContents ? safeSurround(range, span) : span.append(range.extractContents());
    range.insertNode(span);
    // place caret after span
    sel.removeAllRanges(); const r = document.createRange(); r.setStartAfter(span); r.collapse(true); sel.addRange(r);
    onDirty();
  }

  function safeSurround(range, node){
    try { range.surroundContents(node); }
    catch(_) { node.append(range.extractContents()); }
  }

  // --- Paste handling (preserve styles, strip junk) ---
  async function onPasteSanitized(e){
    e.preventDefault();
    const cd = e.clipboardData || window.clipboardData;
    let html = cd?.getData?.('text/html');
    const text = cd.getData('text/plain');
    if (html) {
      execCmd('insertHTML', cleanWordHTML(html));
      onDirty();
      return;
    }
    const imageFile = extractImageFile(cd);
    if (imageFile){
      await insertImageFile(imageFile, { replace: false });
      return;
    }
    if (text) {
      execCmd('insertText', text);
      onDirty();
    }
  }

  function extractImageFile(clipboardData){
    if (!clipboardData) return null;
    if (clipboardData.files && clipboardData.files.length){
      for (const file of clipboardData.files){
        if (file.type && file.type.startsWith('image/')) return file;
      }
    }
    if (clipboardData.items && clipboardData.items.length){
      for (const item of clipboardData.items){
        if (item.kind === 'file' && item.type.startsWith('image/')){
          const file = item.getAsFile();
          if (file) return file;
        }
      }
    }
    return null;
  }

  async function doPaste() {
    if (navigator.clipboard?.read) {
      try {
        const items = await navigator.clipboard.read();
        for (const item of items) {
          if (item.types.includes('text/html')) {
            const blob = await item.getType('text/html');
            const html = await blob.text();
            execCmd('insertHTML', cleanWordHTML(html));
            onDirty();
            return;
          }
          const imageType = item.types.find(t => t.startsWith('image/'));
          if (imageType) {
            const blob = await item.getType(imageType);
            const ext = imageType.split('/')[1] || 'png';
            const file = new File([blob], `clipboard.${ext}`, { type: imageType });
            await insertImageFile(file, { replace: false });
            return;
          }
        }
        const text = await navigator.clipboard.readText();
        if (text) {
          execCmd('insertText', text);
          onDirty();
        }
        return;
      } catch (err) {
        console.warn('Clipboard read failed, falling back', err);
      }
    }
    execCmd('paste'); // fallback (may be blocked / unsanitized)
  }

  function cleanWordHTML(html){
    if (!html) return '';
    html = html.replace(/<!--[\s\S]*?-->/gi, '')
               .replace(/<\/?(o|w):[^>]*>/gi, '')
               .replace(/<\/?v:[^>]*>/gi, '');
    const temp = document.createElement('div');
    temp.innerHTML = html;
    sanitizeFragment(temp);
    return temp.innerHTML;
  }

  function sanitizeFragment(root){
    sanitizeChildren(root);
  }

  function sanitizeChildren(node){
    let child = node.firstChild;
    while (child){
      const next = child.nextSibling;
      sanitizeNode(child);
      child = next;
    }
  }

  function sanitizeNode(node){
    if (node.nodeType === Node.COMMENT_NODE){
      node.remove();
      return;
    }
    if (node.nodeType !== Node.ELEMENT_NODE) return;

    sanitizeChildren(node);

    const tag = node.tagName.toLowerCase();
    if (!ALLOWED_TAGS.has(tag)){
      if (DROP_CONTENT_TAGS.has(tag)){
        node.remove();
        return;
      }
      unwrapNode(node);
      return;
    }

    sanitizeAttributes(node);
  }

  function unwrapNode(node){
    const parent = node.parentNode;
    if (!parent){
      node.remove();
      return;
    }
    while (node.firstChild){
      parent.insertBefore(node.firstChild, node);
    }
    parent.removeChild(node);
  }

  function sanitizeAttributes(el){
    [...el.attributes].forEach(attr => {
      const name = attr.name.toLowerCase();
      const value = attr.value;
      if (!ALLOWED_ATTRS.has(name)){
        el.removeAttribute(attr.name);
        return;
      }
      if (name === 'style'){
        const clean = sanitizeStyle(value);
        if (clean) el.setAttribute('style', clean);
        else el.removeAttribute('style');
        return;
      }
      if (URL_ATTRS.has(name)){
        const safe = sanitizeUrl(value, name);
        if (safe) {
          el.setAttribute(name, safe);
          if (name === 'href'){
            if (!el.hasAttribute('target')) el.setAttribute('target','_blank');
            el.setAttribute('rel','noopener');
          }
        } else {
          el.removeAttribute(name);
        }
        return;
      }
      if (name === 'target'){
        const target = value.trim();
        if (!SAFE_TARGETS.has(target)){
          el.setAttribute('target','_blank');
        }
        return;
      }
      if ((name === 'colspan' || name === 'rowspan') && !/^\d+$/.test(value.trim())){
        el.removeAttribute(name);
      }
    });

    if (el.tagName.toLowerCase() === 'a' && !el.hasAttribute('href')){
      el.removeAttribute('target');
      el.removeAttribute('rel');
    }
  }

  function sanitizeStyle(styleValue){
    if (!styleValue) return '';
    const rules = styleValue.split(';').map(r => r.trim()).filter(Boolean);
    const cleaned = [];
    for (const rule of rules){
      const idx = rule.indexOf(':');
      if (idx === -1) continue;
      const property = rule.slice(0, idx).trim().toLowerCase();
      let value = rule.slice(idx + 1).trim();
      if (!isAllowedStyle(property)) continue;
      if (!value) continue;
      const lowerVal = value.toLowerCase();
      if (lowerVal.includes('expression') || lowerVal.includes('javascript:') || /url\s*\(/i.test(lowerVal)) continue;
      value = value.replace(/!important/gi, '').trim();
      if (!value) continue;
      cleaned.push(`${property}: ${value}`);
    }
    return cleaned.join('; ');
  }

  function isAllowedStyle(property){
    if (ALLOWED_STYLES.has(property)) return true;
    if (property.startsWith('margin') && ALLOWED_STYLES.has('margin')) return true;
    if (property.startsWith('padding') && ALLOWED_STYLES.has('padding')) return true;
    if (property.startsWith('border') && ALLOWED_STYLES.has('border')) return true;
    return false;
  }

  function sanitizeUrl(raw, attr){
    if (!raw) return '';
    const url = raw.trim();
    const lower = url.toLowerCase();
    if (attr === 'src' && lower.startsWith('data:image/')) return url;
    const allowedProtocols = ['http:','https:','mailto:','tel:','//','blob:'];
    if (lower.startsWith('#')) return url;
    if (allowedProtocols.some(proto => lower.startsWith(proto))) return url;
    return '';
  }

  // --- Status & autosave ---
  function updateStats(){
    const t = editor.innerText || '';
    const words = t.trim().split(/\s+/).filter(Boolean).length;
    document.getElementById('statWords').textContent = words;
    document.getElementById('statChars').textContent = t.length;
  }

  function onDirty(){
    if (!isModalOpen) return;
    if (historyIndex >= 0 && docHistory[historyIndex] && docHistory[historyIndex].html === editor.innerHTML){
      needsSave = false;
      saveStatusEl.textContent = 'Ready';
      if (historyDebounce){
        clearTimeout(historyDebounce);
        historyDebounce = null;
      }
      if (autoSaveTimer){
        clearTimeout(autoSaveTimer);
        autoSaveTimer = null;
      }
      return;
    }
    needsSave = true;
    saveStatusEl.textContent = 'Unsaved';
    updateStats();
    queueAutoSave();
    queueHistorySnapshot();
  }

  function queueAutoSave(){
    if (autoSaveTimer) return;
    autoSaveTimer = setTimeout(runAutoSave, 2000);
  }

  function queueHistorySnapshot(){
    if (isApplyingHistory) return;
    if (historyDebounce){
      return;
    }
    historyDebounce = setTimeout(()=> {
      historyDebounce = null;
      pushHistory();
    }, HISTORY_DEBOUNCE_MS);
  }

  function runAutoSave(){
    autoSaveTimer = null;
    if (!needsSave || !isModalOpen) return;
    persistContent();
    needsSave = false;
    saveStatusEl.textContent = 'Auto-saved';
    scheduleStatusReset();
  }

  function scheduleStatusReset(){
    if (statusResetTimer) clearTimeout(statusResetTimer);
    statusResetTimer = setTimeout(()=> {
      if (saveStatusEl.textContent === 'Auto-saved' || saveStatusEl.textContent === 'Saved') {
        saveStatusEl.textContent = 'Ready';
      }
    }, 1500);
  }

  function persistContent(){
    localStorage.setItem(STORAGE_KEY, editor.innerHTML);
  }

  function flushAutoSave(){
    if (!isModalOpen) return;
    if (autoSaveTimer){
      clearTimeout(autoSaveTimer);
      autoSaveTimer = null;
    }
    if (needsSave){
      persistContent();
      needsSave = false;
      saveStatusEl.textContent = 'Saved';
      scheduleStatusReset();
    }
  }

  function pushHistory(providedSnapshot){
    if (isApplyingHistory) return;
    const html = editor.innerHTML;
    const selection = providedSnapshot !== undefined ? providedSnapshot : getSelectionSnapshot();
    if (historyIndex >= 0){
      const current = docHistory[historyIndex];
      if (current && current.html === html){
        docHistory[historyIndex] = { html, selection };
        updateHistoryUI();
        return;
      }
    }
    docHistory = docHistory.slice(0, historyIndex + 1);
    docHistory.push({ html, selection });
    if (docHistory.length > MAX_HISTORY_ENTRIES){
      docHistory.shift();
      historyIndex = historyIndex - 1;
    }
    historyIndex = docHistory.length - 1;
    updateHistoryUI();
  }

  function resetHistory(){
    if (historyDebounce){
      clearTimeout(historyDebounce);
      historyDebounce = null;
    }
    docHistory = [];
    historyIndex = -1;
    pushHistory(getSelectionSnapshot());
  }

  function updateHistoryUI(){
    if (undoBtn){
      undoBtn.disabled = historyIndex <= 0;
    }
    if (redoBtn){
      redoBtn.disabled = historyIndex === -1 || historyIndex >= docHistory.length - 1;
    }
  }

  function undoHistory(){
    if (!isModalOpen) return;
    if (historyIndex <= 0) return;
    historyIndex -= 1;
    applyHistoryState(docHistory[historyIndex]);
  }

  function redoHistory(){
    if (!isModalOpen) return;
    if (historyIndex === -1 || historyIndex >= docHistory.length - 1) return;
    historyIndex += 1;
    applyHistoryState(docHistory[historyIndex]);
  }

  function applyHistoryState(state){
    if (!state) return;
    isApplyingHistory = true;
    if (historyDebounce){
      clearTimeout(historyDebounce);
      historyDebounce = null;
    }
    editor.innerHTML = state.html;
    dismissImageTools();
    dismissTableTools();
    needsSave = true;
    saveStatusEl.textContent = 'Unsaved';
    updateStats();
    updateListStyleControl();
    syncTableSelection();
    if (isModalOpen){
      queueAutoSave();
    }
    const finalize = ()=> {
      applySelectionSnapshot(state.selection);
      try { editor.focus({ preventScroll: true }); } catch(_) { editor.focus(); }
      const latestSnapshot = getSelectionSnapshot();
      if (historyIndex >= 0 && historyIndex < docHistory.length){
        docHistory[historyIndex] = { html: editor.innerHTML, selection: latestSnapshot };
      }
      isApplyingHistory = false;
      updateHistoryUI();
    };
    if (typeof requestAnimationFrame === 'function'){
      requestAnimationFrame(finalize);
    } else {
      finalize();
    }
  }

  function getSelectionSnapshot(){
    const sel = window.getSelection();
    if (!sel || sel.rangeCount === 0) return null;
    const range = sel.getRangeAt(0);
    if (!editor.contains(range.startContainer) || !editor.contains(range.endContainer)){
      return null;
    }
    const startPath = getNodePath(range.startContainer, editor);
    const endPath = getNodePath(range.endContainer, editor);
    if (!startPath || !endPath) return null;
    return {
      start: { path: startPath, offset: range.startOffset },
      end: { path: endPath, offset: range.endOffset }
    };
  }

  function applySelectionSnapshot(snapshot){
    if (!snapshot) return;
    const startNode = getNodeFromPath(snapshot.start?.path, editor);
    const endNode = getNodeFromPath(snapshot.end?.path, editor);
    if (!startNode || !endNode) return;
    const range = document.createRange();
    range.setStart(startNode, Math.min(snapshot.start.offset ?? 0, getNodeMaxOffset(startNode)));
    range.setEnd(endNode, Math.min(snapshot.end.offset ?? 0, getNodeMaxOffset(endNode)));
    const sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);
  }

  function getNodePath(node, root){
    const path = [];
    let current = node;
    while (current && current !== root){
      const parent = current.parentNode;
      if (!parent) return null;
      const index = Array.prototype.indexOf.call(parent.childNodes, current);
      if (index === -1) return null;
      path.unshift(index);
      current = parent;
    }
    if (current !== root) return null;
    return path;
  }

  function getNodeFromPath(path, root){
    if (!Array.isArray(path)) return null;
    let current = root;
    for (const index of path){
      if (!current || !current.childNodes || index < 0 || index >= current.childNodes.length){
        return null;
      }
      current = current.childNodes[index];
    }
    return current;
  }

  function getNodeMaxOffset(node){
    if (!node) return 0;
    if (node.nodeType === Node.TEXT_NODE){
      return node.nodeValue ? node.nodeValue.length : 0;
    }
    return node.childNodes ? node.childNodes.length : 0;
  }

  function getElementsInRange(range){
    const elements = [];
    let root = range.commonAncestorContainer;
    if (root.nodeType !== Node.ELEMENT_NODE){
      root = root.parentElement;
    }
    if (!root) return elements;
    const traverse = (node)=>{
      if (node.nodeType !== Node.ELEMENT_NODE) return;
      if (!range.intersectsNode(node)) return;
      elements.push(node);
      for (const child of node.children){
        traverse(child);
      }
    };
    traverse(root);
    return elements;
  }

  function clearFormatting(){
    if (!isModalOpen) return;
    const snapshot = getSelectionSnapshot();
    document.execCommand('removeFormat', false, null);
    if (snapshot) {
      applySelectionSnapshot(snapshot);
    }
    const sel = window.getSelection();
    if (!sel || sel.rangeCount === 0){
      onDirty();
      return;
    }
    const range = sel.getRangeAt(0);
    const elements = getElementsInRange(range);
    elements.forEach(node => {
      if (node === editor) return;
      if (node.tagName && CLEARABLE_TAGS.has(node.tagName)){
        if (node.hasAttribute('style')){
          node.removeAttribute('style');
        }
        if (node.tagName === 'SPAN' && node.attributes.length === 0){
          unwrapNode(node);
        }
      }
    });
    onDirty();
  }

  // --- File ops ---
  function newDoc(){
    if (!confirm('Create new document? Unsaved changes will be lost.')) return;
    editor.innerHTML = '<p><br></p>';
    localStorage.removeItem(STORAGE_KEY);
    onDirty();
    resetHistory();
  }
  function saveDoc(){
    const content = editor.innerHTML;
    const blob = new Blob([`<!DOCTYPE html><html><head><meta charset="UTF-8"><title>Document</title></head><body>${content}</body></html>`], {type:'text/html'});
    const url = URL.createObjectURL(blob);
    const a = Object.assign(document.createElement('a'), { href: url, download: 'document.html' });
    a.click(); URL.revokeObjectURL(url);
    persistContent();
    needsSave = false;
    saveStatusEl.textContent = 'Saved';
    scheduleStatusReset();
  }
  async function handleOpenFile(e){
    const file = e.target.files?.[0];
    e.target.value = '';
    if (!file) return;
    try {
      if (/\.(docx)$/i.test(file.name)) {
        if (!window.mammoth?.convertToHtml) {
          alert('DOCX support is unavailable. Please ensure mammoth.browser.min.js is loaded.');
          return;
        }
        const arrayBuffer = await file.arrayBuffer();
        const result = await window.mammoth.convertToHtml({ arrayBuffer });
        const html = cleanWordHTML(result.value || '');
        editor.innerHTML = html || '<p><br></p>';
      } else {
        const text = await file.text();
        editor.innerHTML = text || '<p><br></p>';
      }
      updateStats();
      updateListStyleControl();
      syncTableSelection();
      dismissImageTools();
      dismissTableTools();
      resetHistory();
      needsSave = false;
      saveStatusEl.textContent = 'Ready';
    } catch (err) {
      console.error('File import failed', err);
      alert('Unable to import this file. Please confirm it is a valid document.');
    }
  }
  // --- Modals simple helpers ---
  function openModal(id){ document.getElementById(id).classList.add('active'); }
  function closeModal(id){ document.getElementById(id).classList.remove('active'); }

  // --- Link ---
  function openLinkModal(){
    const sel = String(window.getSelection());
    document.getElementById('linkText').value = sel || '';
    document.getElementById('linkURL').value = '';
    openModal('modalLink');
  }
  function doInsertLink(){
    const url = document.getElementById('linkURL').value.trim();
    const text = document.getElementById('linkText').value.trim();
    if (!url){ closeModal('modalLink'); return; }
    if (text){
      execCmd('insertHTML', `<a href="${escapeHtml(url)}" target="_blank" rel="noopener">${escapeHtml(text)}</a>`);
    } else {
      execCmd('createLink', url);
      // ensure target=_blank
      const sel = window.getSelection(); if (sel?.anchorNode) {
        const a = (sel.anchorNode.nodeType===1? sel.anchorNode : sel.anchorNode.parentElement).closest('a');
        if (a){ a.target = '_blank'; a.rel = 'noopener'; }
      }
    }
    closeModal('modalLink'); onDirty();
  }
  function escapeHtml(s){ return s.replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m])); }

  // --- Table ---
  function doInsertTable(){
    const r = Math.max(1, +document.getElementById('tblRows').value||3);
    const c = Math.max(1, +document.getElementById('tblCols').value||3);
    let html = `<table style="width:100%;border-collapse:collapse;border:1px solid #000;">`;
    for (let i=0;i<r;i++){
      html += `<tr>`;
      for (let j=0;j<c;j++){
        html += `<td style="border:1px solid #000;padding:4px;"><p><br></p></td>`;
      }
      html += `</tr>`;
    }
    html += `</table><p><br></p>`;
    execCmd('insertHTML', html);
    closeModal('modalTable'); onDirty();
  }

  // --- Page break ---
  function insertPageBreak(){
    execCmd('insertHTML', `<div class="page-break" contenteditable="false"></div>`);
    onDirty();
  }

  // --- Page setup & zoom ---
  function applyPageSetup(){
    const paper = 'A4';
    const orient = document.getElementById('orientation').value;
    const margin = Math.max(0, +document.getElementById('margin').value || 20);
    const dim = PAPER_MM[paper] || PAPER_MM.A4;
    const W = orient==='portrait' ? dim.w : dim.h;
    const H = orient==='portrait' ? dim.h : dim.w;
    // On-screen size in mm (CSS supports mm)
    pageWrap.style.width = W + 'mm';
    pageWrap.style.minHeight = H + 'mm';
    // Content padding = margins
    if (pageContent) pageContent.style.padding = margin + 'mm';
    // Print @page
    printStyle.textContent = `@page{ size: ${paper} ${orient}; margin: ${margin}mm; }`;
  }
  function applyZoom(){
    const zStr = document.getElementById('zoom').value.replace('%','');
    const z = Math.max(10, +zStr || 100);
    pageWrap.style.transform = `scale(${z/100})`;
  }

  function handleListStyleChange(e){
    const val = e.target.value;
    if (!val || !isModalOpen) return;
    const parts = val.split(':');
    if (parts.length !== 2) return;
    const [listKind, style] = parts;
    const wantsOrdered = listKind === 'ol';
    let list = getClosestList();
    const toggleCmd = wantsOrdered ? 'insertOrderedList' : 'insertUnorderedList';
    if (!list){
      execCmd(toggleCmd);
      list = getClosestList();
    } else {
      const isOrdered = list.tagName.toLowerCase() === 'ol';
      if (isOrdered !== wantsOrdered){
        execCmd(toggleCmd);
        list = getClosestList();
      }
    }
    if (list){
      list.style.listStyleType = style;
      onDirty();
    }
    updateListStyleControl();
  }

  function getClosestList(){
    const sel = window.getSelection();
    if (!sel || sel.rangeCount === 0) return null;
    let node = sel.anchorNode;
    if (!node) return null;
    if (node.nodeType !== Node.ELEMENT_NODE) node = node.parentElement;
    if (!node) return null;
    return node.closest('ul,ol');
  }

  function updateListStyleControl(){
    if (!listStyleSelect) return;
    if (!isModalOpen){
      listStyleSelect.value = '';
      return;
    }
    const list = getClosestList();
    if (!list){
      listStyleSelect.value = '';
      return;
    }
    const tag = list.tagName.toLowerCase();
    let style = (list.style.listStyleType || '').trim();
    if (!style){
      style = window.getComputedStyle(list).listStyleType || '';
    }
    if (!style){
      style = tag === 'ol' ? 'decimal' : 'disc';
    }
    const value = `${tag}:${style}`;
    const hasOption = Array.from(listStyleSelect.options).some(opt => opt.value === value);
    listStyleSelect.value = hasOption ? value : '';
  }

  // --- Find & Replace (simple) ---
  let _lastFindIndex = -1, _lastFindText = '';
  function doFindNext(){
    const needle = document.getElementById('findTxt').value;
    if (!needle) return;
    const html = editor.innerHTML;
    if (_lastFindText !== needle){ _lastFindText = needle; _lastFindIndex = -1; }
    const from = _lastFindIndex + 1;
    const idx = html.toLowerCase().indexOf(needle.toLowerCase(), from);
    if (idx >= 0){
      _lastFindIndex = idx;
      selectHtmlRangeByIndex(editor, idx, needle.length);
    } else { _lastFindIndex = -1; }
  }
  function doReplaceOne(){
    const find = document.getElementById('findTxt').value;
    const repl = document.getElementById('replTxt').value;
    if (!find) return;
    const sel = window.getSelection();
    if (sel && String(sel) && String(sel).toLowerCase()===find.toLowerCase()){
      execCmd('insertText', repl);
      onDirty(); doFindNext();
    } else {
      doFindNext();
    }
  }
  function doReplaceAll(){
    const find = document.getElementById('findTxt').value;
    const repl = document.getElementById('replTxt').value;
    if (!find) return;
    const re = new RegExp(find.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
    editor.innerHTML = editor.innerHTML.replace(re, repl);
    onDirty();
  }
  function selectHtmlRangeByIndex(root, index, length){
    // naive selection across text nodes
    let walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null);
    let pos = 0, startNode=null, startOffset=0, endNode=null, endOffset=0;
    while (walker.nextNode()){
      const n = walker.currentNode, len = n.nodeValue.length;
      if (!startNode && pos + len >= index) { startNode = n; startOffset = index - pos; }
      if (startNode && pos + len >= index + length){ endNode = n; endOffset = index + length - pos; break; }
      pos += len;
    }
    if (startNode && endNode){
      const r = document.createRange(); r.setStart(startNode, startOffset); r.setEnd(endNode, endOffset);
      const sel = window.getSelection(); sel.removeAllRanges(); sel.addRange(r);
    }
  }

  // --- Image Tools ---
  let currentImg = null, naturalRatio = 1;
  const imgTB = document.getElementById('imgToolbar');
  const widthSlider = document.getElementById('imgWidth');
  const lockRatio = document.getElementById('imgLock');
  const sizeLabel = document.getElementById('imgSizeLabel');
  let currentCell = null;
  const tableTB = document.getElementById('tableToolbar');

  function wireImageTools(){
    // click to open toolbar
    editor.addEventListener('click', e => {
      const img = e.target.closest('img');
      if (img) selectImage(img);
      else dismissImageTools();
    });
    // keyboard/mouse outside
    document.addEventListener('scroll', positionToolbar, true);
    window.addEventListener('resize', positionToolbar);

    // controls
    widthSlider.oninput = ()=> applyImgWidth(+widthSlider.value);
    document.getElementById('imgAlignLeft').onclick = ()=> setImgAlign('left');
    document.getElementById('imgAlignCenter').onclick = ()=> setImgAlign('center');
    document.getElementById('imgAlignRight').onclick = ()=> setImgAlign('right');
    document.getElementById('imgFloatLeft').onclick = ()=> setImgFloat('left');
    document.getElementById('imgFloatRight').onclick = ()=> setImgFloat('right');
    document.getElementById('imgFloatNone').onclick = ()=> setImgFloat('none');
    document.getElementById('imgBorderToggle').onclick = toggleImgBorder;
    document.getElementById('imgRadius').oninput = (e)=> setImgRadius(+e.target.value);
    document.getElementById('imgShadowToggle').onclick = toggleImgShadow;
    document.getElementById('imgReplace').onclick = replaceImgURL;
    document.getElementById('imgUpload').onclick = ()=> { pendingImageInsert = false; fileImgInput.click(); };
    document.getElementById('imgRemove').onclick = removeImg;
    fileImgInput.addEventListener('change', handleImgUpload);
  }

  function wireTableTools(){
    if (!tableTB) return;
    editor.addEventListener('click', e => {
      const cell = e.target.closest('td,th');
      if (cell) selectTableCell(cell);
      else if (!e.target.closest('.table-toolbar')) dismissTableTools();
    });
    document.addEventListener('click', e => {
      if (!editor.contains(e.target) && !tableTB.contains(e.target)) dismissTableTools();
    });
    tableTB.addEventListener('mousedown', e => e.preventDefault());
    const bind = (id, handler)=>{
      const btn = document.getElementById(id);
      if (btn) btn.onclick = handler;
    };
    bind('tblAddRowAbove', ()=> modifyTableRow('above'));
    bind('tblAddRowBelow', ()=> modifyTableRow('below'));
    bind('tblAddColLeft', ()=> modifyTableColumn('left'));
    bind('tblAddColRight', ()=> modifyTableColumn('right'));
    bind('tblDeleteRow', deleteTableRow);
    bind('tblDeleteCol', deleteTableColumn);
    bind('tblToggleHeader', toggleTableHeader);
    bind('tblAlignLeft', ()=> setCellAlignment('left'));
    bind('tblAlignCenter', ()=> setCellAlignment('center'));
    bind('tblAlignRight', ()=> setCellAlignment('right'));
    tableTB.querySelectorAll('[data-border]').forEach(btn => {
      btn.addEventListener('click', ()=> applyCellBorder(btn.getAttribute('data-border')));
    });
    window.addEventListener('resize', positionTableToolbar);
    document.addEventListener('scroll', positionTableToolbar, true);
  }

  function selectTableCell(cell){
    if (!tableTB || !cell) return;
    if (currentCell === cell){
      positionTableToolbar();
      return;
    }
    if (currentCell) currentCell.classList.remove('cell-selected');
    currentCell = cell;
    currentCell.classList.add('cell-selected');
    tableTB.style.display = 'block';
    positionTableToolbar();
  }

  function dismissTableTools(){
    if (currentCell) currentCell.classList.remove('cell-selected');
    currentCell = null;
    if (tableTB) tableTB.style.display = 'none';
  }

  function positionTableToolbar(){
    if (!tableTB || !currentCell || tableTB.style.display === 'none') return;
    const rect = currentCell.getBoundingClientRect();
    const top = Math.max(8, rect.top + window.scrollY - tableTB.offsetHeight - 10);
    const left = Math.min(window.scrollX + rect.left, window.scrollX + window.innerWidth - tableTB.offsetWidth - 8);
    tableTB.style.top = `${top}px`;
    tableTB.style.left = `${left}px`;
  }

  function tableHasMergedCells(table){
    if (!table) return false;
    return Array.from(table.rows).some(row =>
      Array.from(row.cells).some(cell => cell.colSpan > 1 || cell.rowSpan > 1));
  }

  function modifyTableRow(where){
    if (!currentCell) return;
    const row = currentCell.parentElement;
    if (!row) return;
    const table = row.closest('table');
    if (tableHasMergedCells(table)) {
      alert('Table row operations are disabled when merged cells are present.');
      return;
    }
    const container = row.parentElement;
    const clone = row.cloneNode(true);
    Array.from(clone.cells).forEach(cell => {
      cell.innerHTML = '<p><br></p>';
      cell.classList.remove('cell-selected');
    });
    if (where === 'above') container.insertBefore(clone, row);
    else container.insertBefore(clone, row.nextSibling);
    onDirty();
    const targetIndex = Math.min(currentCell.cellIndex, clone.cells.length - 1);
    selectTableCell(clone.cells[targetIndex]);
  }

  function modifyTableColumn(where){
    if (!currentCell) return;
    const table = currentCell.closest('table');
    if (!table) return;
    if (tableHasMergedCells(table)) {
      alert('Table column operations are disabled when merged cells are present.');
      return;
    }
    const index = currentCell.cellIndex;
    let inserted = null;
    Array.from(table.rows).forEach(row => {
      const reference = row.cells[index] || row.cells[row.cells.length - 1];
      const source = reference || document.createElement(row.parentElement.tagName.toLowerCase() === 'thead' ? 'th' : 'td');
      const newCell = source.cloneNode(false);
      newCell.innerHTML = '<p><br></p>';
      newCell.classList.remove('cell-selected');
      newCell.colSpan = 1;
      newCell.rowSpan = 1;
      newCell.style.cssText = source.style?.cssText || '';
      if (where === 'left'){
        row.insertBefore(newCell, row.cells[index] || null);
      } else {
        row.insertBefore(newCell, row.cells[index + 1] || null);
      }
      if (row === currentCell.parentElement) inserted = newCell;
    });
    onDirty();
    if (inserted) selectTableCell(inserted);
  }

  function deleteTableRow(){
    if (!currentCell) return;
    const table = currentCell.closest('table');
    if (!table) return;
    if (tableHasMergedCells(table)) {
      alert('Delete row is disabled when merged cells are present.');
      return;
    }
    const row = currentCell.parentElement;
    const rowIndex = Array.from(table.rows).indexOf(row);
    const cellIndex = currentCell.cellIndex;
    row.remove();
    onDirty();
    if (!table.rows.length){
      table.remove();
      dismissTableTools();
      return;
    }
    const nextRow = table.rows[Math.min(rowIndex, table.rows.length - 1)];
    if (!nextRow || !nextRow.cells.length){
      dismissTableTools();
      return;
    }
    const nextCell = nextRow.cells[Math.min(cellIndex, nextRow.cells.length - 1)];
    if (nextCell) selectTableCell(nextCell);
    else dismissTableTools();
  }

  function deleteTableColumn(){
    if (!currentCell) return;
    const table = currentCell.closest('table');
    if (!table) return;
    if (tableHasMergedCells(table)) {
      alert('Delete column is disabled when merged cells are present.');
      return;
    }
    const colIndex = currentCell.cellIndex;
    const rowIndex = Array.from(table.rows).indexOf(currentCell.parentElement);
    Array.from(table.rows).forEach(row => {
      if (row.cells[colIndex]) row.cells[colIndex].remove();
    });
    onDirty();
    if (!table.rows.length || !table.rows[0].cells.length){
      table.remove();
      dismissTableTools();
      return;
    }
    const targetRow = table.rows[Math.min(rowIndex, table.rows.length - 1)];
    const newIndex = Math.min(colIndex, targetRow.cells.length - 1);
    const nextCell = targetRow.cells[newIndex];
    if (nextCell) selectTableCell(nextCell);
    else dismissTableTools();
  }

  function toggleTableHeader(){
    if (!currentCell) return;
    const table = currentCell.closest('table');
    if (!table) return;
    if (tableHasMergedCells(table)) {
      alert('Header toggle is disabled when merged cells are present.');
      return;
    }
    const tbody = table.tBodies[0] || table.createTBody();
    if (table.tHead){
      const headRow = table.tHead.rows[0];
      if (headRow){
        const newRow = document.createElement('tr');
        Array.from(headRow.cells).forEach(cell => {
          const td = document.createElement('td');
          td.innerHTML = cell.innerHTML || '<p><br></p>';
          td.style.cssText = cell.style.cssText;
          td.colSpan = cell.colSpan;
          td.rowSpan = cell.rowSpan;
          newRow.appendChild(td);
        });
        tbody.insertBefore(newRow, tbody.firstChild);
        selectTableCell(newRow.cells[Math.min(currentCell.cellIndex, newRow.cells.length - 1)]);
      }
      table.deleteTHead();
    } else {
      if (!tbody.rows.length) return;
      const firstRow = tbody.rows[0];
      const thead = table.createTHead();
      const headRow = thead.insertRow();
      Array.from(firstRow.cells).forEach(cell => {
        const th = document.createElement('th');
        th.innerHTML = cell.innerHTML;
        th.style.cssText = cell.style.cssText;
        th.colSpan = cell.colSpan;
        th.rowSpan = cell.rowSpan;
        headRow.appendChild(th);
      });
      selectTableCell(headRow.cells[Math.min(currentCell.cellIndex, headRow.cells.length - 1)]);
      firstRow.remove();
      if (!tbody.rows.length){
        const filler = document.createElement('tr');
        Array.from(headRow.cells).forEach(()=>{
          const td = document.createElement('td');
          td.innerHTML = '<p><br></p>';
          filler.appendChild(td);
        });
        tbody.appendChild(filler);
      }
    }
    onDirty();
  }

  function setCellAlignment(mode){
    if (!currentCell) return;
    currentCell.style.textAlign = mode;
    onDirty();
    positionTableToolbar();
  }

  function applyCellBorder(mode){
    if (!currentCell) return;
    const borderStyle = '1px solid #000';
    if (mode === 'all'){
      currentCell.style.border = borderStyle;
    } else if (mode === 'none'){
      currentCell.style.border = 'none';
    } else {
      const map = { top: 'borderTop', right: 'borderRight', bottom: 'borderBottom', left: 'borderLeft' };
      const prop = map[mode];
      if (!prop) return;
      const computed = window.getComputedStyle(currentCell)[prop];
      const current = currentCell.style[prop];
      const isActive = current && current !== 'none' ? true : (computed && !/none|0px/.test(computed));
      currentCell.style[prop] = isActive ? 'none' : borderStyle;
    }
    onDirty();
    positionTableToolbar();
  }

  function getClosestCell(){
    const sel = window.getSelection();
    if (!sel || sel.rangeCount === 0) return null;
    let node = sel.anchorNode;
    if (!node) return null;
    if (node.nodeType !== Node.ELEMENT_NODE) node = node.parentElement;
    if (!node) return null;
    return node.closest('td,th');
  }

  function syncTableSelection(){
    if (!isModalOpen){
      dismissTableTools();
      return;
    }
    const cell = getClosestCell();
    if (cell) selectTableCell(cell);
    else dismissTableTools();
  }

  function selectImage(img){
    if (currentImg && currentImg!==img) unmarkImage(currentImg);
    currentImg = img;
    naturalRatio = (img.naturalWidth && img.naturalHeight) ? (img.naturalHeight ? img.naturalWidth/img.naturalHeight : 1) : (img.width && img.height ? img.width/img.height : 1);
    img.classList.add('img-selected');
    ensureImgHandle(img);
    widthSlider.max = Math.max(1600, Math.round(getContentMaxWidth()));
    widthSlider.value = Math.round(img.width || 300);
    updateImgSizeLabel();
    showToolbarNear(img);
  }

  function unmarkImage(img){
    img.classList.remove('img-selected');
    const h = img._handleEl; if (h && h.parentNode) h.parentNode.removeChild(h);
    img._handleEl = null;
  }

  function ensureImgHandle(img){
    if (img._handleEl) return;
    const h = document.createElement('div');
    h.className = 'img-handle';
    h.style.position = 'absolute';
    // parent must be relative to position handle
    const posWrapper = img.parentElement;
    if (getComputedStyle(posWrapper).position === 'static') posWrapper.style.position = 'relative';
    posWrapper.appendChild(h);
    img._handleEl = h;
    positionHandle(img);
    // drag to resize
    let dragging=false, startX=0, startW=0;
    h.addEventListener('mousedown', (e)=>{
      e.preventDefault(); dragging=true; startX=e.clientX; startW=img.width;
      document.body.style.userSelect='none';
    });
    window.addEventListener('mousemove', (e)=>{
      if (!dragging) return;
      const dx = e.clientX - startX;
      applyImgWidth(Math.max(20, startW + dx));
    });
    window.addEventListener('mouseup', ()=>{
      if (dragging){ dragging=false; document.body.style.userSelect=''; onDirty(); }
    });
  }

  function positionHandle(img){
    const h = img._handleEl; if (!h) return;
    const r = img.getBoundingClientRect();
    const pr = img.parentElement.getBoundingClientRect();
    h.style.left = (r.right - pr.left - 5) + 'px';
    h.style.top  = (r.bottom - pr.top - 5) + 'px';
  }

  function showToolbarNear(img){
    imgTB.style.display = 'block';
    positionToolbar();
  }
  function positionToolbar(){
    if (!currentImg) return;
    const r = currentImg.getBoundingClientRect();
    const top = Math.max(8, r.top + window.scrollY - imgTB.offsetHeight - 10);
    const left = Math.min(window.scrollX + r.left, window.scrollX + window.innerWidth - imgTB.offsetWidth - 8);
    imgTB.style.top = top + 'px';
    imgTB.style.left = left + 'px';
    // update handle position too
    positionHandle(currentImg);
  }
  function dismissImageTools(){
    if (currentImg) unmarkImage(currentImg);
    currentImg = null;
    imgTB.style.display = 'none';
  }

  function applyImgWidth(w){
    if (!currentImg) return;
    currentImg.style.width = w + 'px';
    if (lockRatio.checked && naturalRatio){
      currentImg.style.height = Math.round(w / naturalRatio) + 'px';
    } else {
      currentImg.style.height = 'auto';
    }
    widthSlider.value = Math.round(w);
    updateImgSizeLabel();
    positionToolbar();
    onDirty();
  }
  function updateImgSizeLabel(){
    if (!currentImg){ sizeLabel.textContent = ''; return; }
    sizeLabel.textContent = `${Math.round(currentImg.getBoundingClientRect().width)}√ó${Math.round(currentImg.getBoundingClientRect().height)} px`;
  }

  function setImgAlign(where){
    if (!currentImg) return;
    currentImg.style.display = 'block';
    currentImg.style.float = 'none';
    currentImg.style.margin = '0';
    if (where==='left'){ currentImg.style.marginRight = 'auto'; }
    if (where==='center'){ currentImg.style.margin = '0 auto'; }
    if (where==='right'){ currentImg.style.marginLeft = 'auto'; }
    positionToolbar(); onDirty();
  }
  function setImgFloat(where){
    if (!currentImg) return;
    currentImg.style.display = 'inline-block';
    if (where==='left'){ currentImg.style.float = 'left'; currentImg.style.margin = '0 12px 8px 0'; }
    else if (where==='right'){ currentImg.style.float = 'right'; currentImg.style.margin = '0 0 8px 12px'; }
    else { currentImg.style.float = 'none'; currentImg.style.margin = '0'; }
    positionToolbar(); onDirty();
  }
  function toggleImgBorder(){
    if (!currentImg) return;
    const has = currentImg.style.border && currentImg.style.border !== 'none';
    currentImg.style.border = has ? 'none' : '1px solid #000';
    onDirty();
  }
  function setImgRadius(v){
    if (!currentImg) return;
    currentImg.style.borderRadius = v + 'px';
    onDirty();
  }
  function toggleImgShadow(){
    if (!currentImg) return;
    const has = currentImg.style.boxShadow && currentImg.style.boxShadow !== 'none';
    currentImg.style.boxShadow = has ? 'none' : '0 6px 18px rgba(0,0,0,.25)';
    onDirty();
  }
  function replaceImgURL(){
    if (!currentImg) return;
    const u = prompt('Image URL:', currentImg.src || '');
    if (!u) return;
    const safe = sanitizeUrl(u, 'src');
    if (!safe){
      alert('Please enter a safe image URL (http/https/data).');
      return;
    }
    currentImg.addEventListener('load', ()=> { updateImgSizeLabel(); positionToolbar(); }, { once: true });
    currentImg.src = safe;
    onDirty();
  }
  async function handleImgUpload(e){
    const file = e.target.files?.[0];
    e.target.value = '';
    if (!file) return;
    const replace = !pendingImageInsert && !!currentImg;
    await insertImageFile(file, { replace });
    pendingImageInsert = false;
  }

  async function insertImageFile(file, { replace = false } = {}){
    if (!file || !(file.type || '').startsWith('image/')) return;
    try {
      const dataUrl = await processImageFile(file);
      if (!dataUrl) return;
      if (replace && currentImg){
        currentImg.addEventListener('load', ()=> { updateImgSizeLabel(); positionToolbar(); }, { once: true });
        currentImg.src = dataUrl;
        onDirty();
      } else {
        execCmd('insertImage', dataUrl);
        onDirty();
        focusLastImage();
      }
    } catch (err) {
      console.error('Image insert failed', err);
      alert('Unable to insert image. Please try a different file.');
    }
  }

  async function processImageFile(file){
    const dataUrl = await readFileAsDataURL(file);
    if (!dataUrl) return '';
    const type = file.type || '';
    if (type === 'image/svg+xml' || type === 'image/gif') {
      return dataUrl;
    }
    const img = await loadImageElement(dataUrl);
    if (!img.naturalWidth || !img.naturalHeight) return dataUrl;
    const maxWidth = getContentMaxWidth();
    const needsResize = img.naturalWidth > maxWidth;
    const needsCompress = file.size > MAX_IMAGE_BYTES || needsResize;
    if (!needsCompress) return dataUrl;
    const targetWidth = Math.min(img.naturalWidth, maxWidth);
    const scale = targetWidth / img.naturalWidth;
    const targetHeight = Math.max(1, Math.round(img.naturalHeight * scale));
    const canvas = document.createElement('canvas');
    canvas.width = targetWidth;
    canvas.height = targetHeight;
    const ctx = canvas.getContext('2d');
    if (!ctx) return dataUrl;
    ctx.clearRect(0, 0, targetWidth, targetHeight);
    ctx.drawImage(img, 0, 0, targetWidth, targetHeight);
    const mimeType = type === 'image/png' ? 'image/png' : 'image/jpeg';
    const quality = mimeType === 'image/jpeg' ? IMAGE_QUALITY : 0.92;
    const compressed = canvas.toDataURL(mimeType, quality);
    if (compressed && (needsResize || compressed.length < dataUrl.length)) {
      return compressed;
    }
    return dataUrl;
  }

  function getContentMaxWidth(){
    if (!pageContent) return 1024;
    return Math.max(320, Math.floor(pageContent.clientWidth || 1024));
  }

  function readFileAsDataURL(file){
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = ev => resolve(ev.target?.result);
      reader.onerror = reject;
      reader.readAsDataURL(file);
    });
  }

  function loadImageElement(src){
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = ()=> resolve(img);
      img.onerror = reject;
      img.src = src;
    });
  }

  function focusLastImage(){
    if (!isModalOpen) return;
    const imgs = editor.querySelectorAll('img');
    if (!imgs.length) return;
    selectImage(imgs[imgs.length - 1]);
  }
  function removeImg(){
    if (!currentImg) return;
    const p = currentImg.parentElement;
    currentImg.remove();
    if (p && p.classList?.contains('img-handle')) p.remove();
    dismissImageTools();
    onDirty();
  }

  // --- Insert image from toolbar button ---
  document.getElementById('btnImage').addEventListener('click', ()=>{
    const raw = prompt('Image URL (or leave blank to upload):', '');
    if (raw && raw.trim()){
      const safe = sanitizeUrl(raw.trim(), 'src');
      if (!safe){
        alert('Please enter a safe image URL (http/https/data).');
        return;
      }
      execCmd('insertImage', safe);
      onDirty();
      focusLastImage();
    } else {
      pendingImageInsert = true;
      fileImgInput.click();
    }
  });

  // --- Table selection state etc. (optional active buttons) ---
  document.addEventListener('selectionchange', ()=>{
    // could toggle .active on buttons using document.queryCommandState(cmd) if desired
    if (currentImg && !editor.contains(currentImg)) dismissImageTools();
    updateListStyleControl();
    syncTableSelection();
  });

</script>
</body>
</html>
